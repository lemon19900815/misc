[TOC]

# 插入排序

## 算法思想

- 对于少量元素的排序，它是一个有效的算法。插入排序是一种 **最简单** 的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而产生一个新的排好序的表。
- 一般使用双循环实现该算法，第一层循环从序列的 **i = 1** 开始往后递增，第二层循环从 **j = i** 位置开始往前递减。
- 参考实现 `insertSort`

## 问题分析

- 复制次数太多。插入排序的时间复杂度为o(n^2)，空间复杂度为o(1)，具体时间复杂度和数组的有序性也是有关联的。假设一个很小的数据项在很靠近右端的位置上，这里本来应该是值比较大的数据项所在的位置，把这个小的数据项移动到左边的正确位置上，所有的中间项数据都必须向右移动一位。这个步骤会导致对每一个数据项都执行了N次复制。虽然不是所有的数据项都需要移动N次，但是平均来看移动N/2次。

  

# 希尔排序

## 算法思想

- 希尔排序是对插入排序的一种改进，它第一次跨过了插入排序o(n^2)的消耗，算法主要由计算机科学家*Donald L. Shell*而得名。
- 插入排序的主要问题是复制次数太多。回想一下在插入排序执行超过一半的时候，标记左边的这部分数据是排过序的，标记右边的数据是没有排过序的。插入排序每次取出当前的数据依次往左移动，造成数据复制过多。
- 希尔排序基于插入排序，通过 **N-增量** 进行排序，每次移动 **gap** 步，从而减少数据的复制。
- N-增量一般选取排序列表的长度的 **1/2, 1/4, 1/8...**，依次做排序。也有其他选取增量的方式，比如间隔序列（***Kunth*序列 h=3*b+1**）。增量可以使用递推公式减少乘法运算。
- 当h值很大时，数据项的每次移动（复制）个数就变的很少，但数据项的移动距离很长，这是非常有效率的。当h减小时，每一趟的排序需要移动的元素个数增多，但是此时数据项已经接近于它们排序后的最终位置，这对于插入排序可以更有效率。正是这两种情况的结合才使得希尔排序的效率那么高。
- 注意后期的排序过程不会撤销前期排序所做的工作。比如，已经完成以40-增量的排序数组，在经过13-增量的排序后仍然保持了以40-增量的排序的结果。如果不是这样的话，希尔排序就无法实现排序的目的。
- 参考实现 `shellSort`



# 归并排序

## 算法思想

- 通过对2个排序好的数组进行合并，从而得到一个完整的有序数组。即先使子序列有序，再使序列段有序。若将两个有序表合并成一个有序表，称为二路归并。
- 该算法是一个典型的分治法实现思想。
- 每次合并数组的时候需要创建一个临时数组去存放数据，合并完成之后再拷贝回去。算法在实现的时候，通过构建一个和原始数组一样的临时数组，而避免每次去构建，从而提升算法性能。
- 当有 n 个记录时，需进行 logn 轮归并排序，每一轮归并，其比较次数不超过 n，元素移动次数都是 n，因此，归并排序的时间复杂度为 O(nlogn)。归并排序时需要和待排序记录个数相等的存储空间，所以空间复杂度为 O(n)。
- 参考实现 `mergeSort`



# 快速排序

## 算法思想

- 快速排序的主要思想是选取一个枢纽元pivot，把比枢纽元小的数据项放到左边，比枢纽元大的数据项放到右边。递归重复上述步骤，即可完成排序操作。

- 简单起见，一般选则第一个元素作为枢纽元。

- 选取枢纽元问题分析

  - 选取第一个元素作为枢纽元。极端情况下如果该枢纽元刚好是最大或者最小的数据项，那么对序列划分变成1和N-1两个子序列。这种情况算法的运行效率完全取决于输入数据，导致算法运行效率不稳定。

  - 随机选取枢纽元。这种情况比随机选取枢纽元，会稳定一些，不过加入随机操作会增加算法复杂度。


- 优化枢纽元
  - 选取中位数，中位数枢纽元是最适合该算法的对序列进行划分的，几乎可以对序列进行N/2划分。真实的中位数对没有排序的序列不能直接获取，所以这里取三个数的中位数（**参考median3实现**），选开始 **left**、结束 **right**、中间 **center=(left+right)/2**三个数的中位数。选取的过程中把这3个数据项排序，并把枢纽元交换到 **right-1** 的位置。循环 **i** 从 **left+1** 开始一直往后 **++** 直到一个比 **pivot**大的数据项，**j** 从 **right-2** 开始向前 **--** 直到一个比 **pivot** 小的数据项，交换 **i，j** 数据项，重复上述步骤，直到**i>=j** 中断，再把枢纽元换回到 **i** 的位置。代码实现中有一个特殊的小技巧，避免数据项的值相等造成死循环问题。

- 参考实现 `quickSort`



# topK算法

## 算法思想

- 快速选择算法是针对快速排序做特殊的调整。在快速排序的过程中，进行子序列划分时，当 **i > k** 时，只对左边的子序列做快速选择，当 **i < k**时，对右边的子序列做快速选择。不会对另外一侧的子序列进行处理，因此可以在o(N)的时间复杂度内完成。
- 快速选择完成时，数据索引为 **K-1** 就是排名为 **k** 的数据。
- 时间复杂度为o(n)。
- 参考实现 `topK`，内部实现为 `quickSelect`



# 堆排序

## 堆介绍

- 堆中某个节点的值总是不大于或不小于其父节点的值。

- 堆总是一棵完全二叉树。

- 父节点为 **i**，左子节点为 **2*i**，右子节点为 **2*i+1**。如果当前节点为 **i**，则父节点为 **⌊i/2⌋**。

## 算法思想：最大堆实现

- 在排序前，先构建最大堆，由于堆的性质，构建需要从整个排序序列的中间开始。具体可以参考（**buildHeap实现**）。
- 从 **j = n-1** 开始，依次递减，把最大的数据 **a[0]** 交换到堆的最后 **a[j]**。这一步操作相当于删除了最大的元素。
- 对 **a[0]** 元素进行下滤，**percolateDown(a, 0, j)**。
- 重复2、3步，直到完成排序。
- **percolateDown** （下滤）说明：依次调节当前节点，依次检查当前节点，左子节点和右子节点，选取较大的节点往上升，将当前节点下滤。
- 参考实现 `heapSort`

## 分析

- 这个算法的时间复杂度是O(NlogN)。下滤操作消耗O(logN)，总共N个数，所以耗时O(NlogN)。
- 最小堆可以应用于定时器的实现。