# 堆排序
**堆介绍：**

1、堆中某个节点的值总是不大于或不小于其父节点的值。

2、堆总是一棵完全二叉树。

3、父节点为 **i**，左子节点为 **2*i**，右子节点为 **2*i+1**。如果当前节点为 **i**，则父节点为 **⌊i/2⌋**。



**算法思想：最大堆实现**

1、在排序前，先构建最大堆，由于堆的性质，构建需要从整个排序序列的中间开始。具体可以参考（**buildHeap实现**）。

2、从 **j = n-1** 开始，依次递减，把最大的数据 **a[0]** 交换到堆的最后 **a[j]**。这一步操作相当于删除了最大的元素。

3、对 **a[0]** 元素进行下滤，**percolateDown(a, 0, j)**。

4、重复2、3步，直到完成排序。

**percolateDown** （下滤）说明：依次调节当前节点，依次检查当前节点，左子节点和右子节点，选取较大的节点往上升，将当前节点下滤。



**分析：**

1、这个算法的时间复杂度是O(NlogN)。下滤操作消耗O(logN)，总共N个数，所以耗时O(NlogN)。

2、最小堆可以应用于定时器的实现。

